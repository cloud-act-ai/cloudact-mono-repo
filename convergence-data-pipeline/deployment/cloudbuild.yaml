# Cloud Build Configuration
# Builds and deploys the Convergence Data Pipeline to Cloud Run
# Enhanced with multi-environment support, health checks, and rollback capability

steps:
  # Step 0: Determine environment from branch
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'setup-env'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Branch: ${BRANCH_NAME}"

        # Determine environment based on branch or substitution
        if [[ "${_ENVIRONMENT}" != "" ]]; then
          ENV="${_ENVIRONMENT}"
        elif [[ "${BRANCH_NAME}" == "main" ]]; then
          ENV="production"
        elif [[ "${BRANCH_NAME}" == "develop" ]]; then
          ENV="staging"
        else
          ENV="development"
        fi

        echo "Deploying to environment: $ENV"
        echo "$ENV" > /workspace/environment.txt

        # Set service name based on environment
        case $ENV in
          production)
            echo "convergence-api" > /workspace/service_name.txt
            echo "2" > /workspace/min_instances.txt
            echo "50" > /workspace/max_instances.txt
            echo "4Gi" > /workspace/memory.txt
            echo "4" > /workspace/cpu.txt
            ;;
          staging)
            echo "convergence-api-staging" > /workspace/service_name.txt
            echo "1" > /workspace/min_instances.txt
            echo "10" > /workspace/max_instances.txt
            echo "2Gi" > /workspace/memory.txt
            echo "2" > /workspace/cpu.txt
            ;;
          *)
            echo "convergence-api-dev" > /workspace/service_name.txt
            echo "0" > /workspace/min_instances.txt
            echo "5" > /workspace/max_instances.txt
            echo "2Gi" > /workspace/memory.txt
            echo "2" > /workspace/cpu.txt
            ;;
        esac

  # Step 1: Run quick tests
  - name: 'python:3.11-slim'
    id: 'quick-test'
    waitFor: ['setup-env']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Running quick validation tests..."
        pip install --quiet -r requirements.txt pytest
        pytest tests/unit/ -v --maxfail=1 -x || {
          echo "Tests failed! Aborting deployment."
          exit 1
        }

  # Step 2: Build Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build-image'
    waitFor: ['quick-test']
    args:
      - 'build'
      - '-t'
      - 'us-docker.pkg.dev/${PROJECT_ID}/convergence/api:${SHORT_SHA}'
      - '-t'
      - 'us-docker.pkg.dev/${PROJECT_ID}/convergence/api:${BRANCH_NAME}-latest'
      - '-t'
      - 'us-docker.pkg.dev/${PROJECT_ID}/convergence/api:latest'
      - '--build-arg'
      - 'BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")'
      - '--build-arg'
      - 'VCS_REF=${SHORT_SHA}'
      - '--build-arg'
      - 'VERSION=${TAG_NAME:-${SHORT_SHA}}'
      - '-f'
      - 'deployment/Dockerfile'
      - '.'

  # Step 3: Push image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'push-image'
    waitFor: ['build-image']
    args:
      - 'push'
      - '--all-tags'
      - 'us-docker.pkg.dev/${PROJECT_ID}/convergence/api'

  # Step 4: Backup current revision (for rollback)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'backup-revision'
    waitFor: ['push-image']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_NAME=$(cat /workspace/service_name.txt)

        echo "Backing up current revision of $SERVICE_NAME..."
        gcloud run services describe $SERVICE_NAME \
          --region=${_REGION} \
          --format='value(status.latestReadyRevisionName)' \
          > /workspace/previous_revision.txt 2>/dev/null || echo "no-previous" > /workspace/previous_revision.txt

        PREV_REV=$(cat /workspace/previous_revision.txt)
        echo "Previous revision: $PREV_REV"

  # Step 5: Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'deploy'
    waitFor: ['backup-revision']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_NAME=$(cat /workspace/service_name.txt)
        ENVIRONMENT=$(cat /workspace/environment.txt)
        MIN_INSTANCES=$(cat /workspace/min_instances.txt)
        MAX_INSTANCES=$(cat /workspace/max_instances.txt)
        MEMORY=$(cat /workspace/memory.txt)
        CPU=$(cat /workspace/cpu.txt)

        echo "Deploying $SERVICE_NAME to $ENVIRONMENT..."

        gcloud run deploy $SERVICE_NAME \
          --image=us-docker.pkg.dev/${PROJECT_ID}/convergence/api:${SHORT_SHA} \
          --region=${_REGION} \
          --platform=managed \
          --service-account=convergence-api@${PROJECT_ID}.iam.gserviceaccount.com \
          --set-env-vars=GCP_PROJECT_ID=${PROJECT_ID},BIGQUERY_LOCATION=US,ENVIRONMENT=$ENVIRONMENT,VERSION=${SHORT_SHA} \
          --allow-unauthenticated \
          --memory=$MEMORY \
          --cpu=$CPU \
          --concurrency=80 \
          --max-instances=$MAX_INSTANCES \
          --min-instances=$MIN_INSTANCES \
          --timeout=3600 \
          --no-traffic \
          --tag=candidate

        # Get the new revision
        NEW_REVISION=$(gcloud run services describe $SERVICE_NAME \
          --region=${_REGION} \
          --format='value(status.latestCreatedRevisionName)')

        echo "$NEW_REVISION" > /workspace/new_revision.txt
        echo "New revision: $NEW_REVISION"

  # Step 6: Health check on new revision
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'health-check'
    waitFor: ['deploy']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_NAME=$(cat /workspace/service_name.txt)

        # Get the candidate URL
        CANDIDATE_URL=$(gcloud run services describe $SERVICE_NAME \
          --region=${_REGION} \
          --format='value(status.traffic.where(tag="candidate").url)')

        echo "Testing candidate revision at: $CANDIDATE_URL"

        # Wait for service to be ready
        sleep 30

        # Perform health check
        for i in {1..5}; do
          echo "Health check attempt $i/5..."

          response=$(curl -s -o /dev/null -w "%{http_code}" "$CANDIDATE_URL/health" || echo "000")

          if [[ "$response" == "200" ]]; then
            echo "Health check passed!"
            exit 0
          fi

          echo "Health check failed with status $response. Retrying..."
          sleep 10
        done

        echo "Health check failed after 5 attempts!"
        exit 1

  # Step 7: Gradual traffic migration
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'traffic-migration'
    waitFor: ['health-check']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_NAME=$(cat /workspace/service_name.txt)
        NEW_REVISION=$(cat /workspace/new_revision.txt)

        echo "Migrating traffic to new revision: $NEW_REVISION"

        # Gradual rollout: 25%, 50%, 100%
        for traffic in 25 50 100; do
          echo "Setting traffic to $traffic%..."

          gcloud run services update-traffic $SERVICE_NAME \
            --region=${_REGION} \
            --to-revisions=$NEW_REVISION=$traffic

          if [[ $traffic -lt 100 ]]; then
            echo "Waiting 60 seconds before next traffic increase..."
            sleep 60
          fi
        done

        echo "Traffic migration complete!"

  # Step 8: Verify deployment
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'verify'
    waitFor: ['traffic-migration']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_NAME=$(cat /workspace/service_name.txt)

        # Get service URL
        SERVICE_URL=$(gcloud run services describe $SERVICE_NAME \
          --region=${_REGION} \
          --format='value(status.url)')

        echo "Verifying deployment at: $SERVICE_URL"

        # Final health check
        response=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL/health")

        if [[ "$response" == "200" ]]; then
          echo "Deployment verified successfully!"
          echo "$SERVICE_URL" > /workspace/service_url.txt
        else
          echo "Deployment verification failed!"
          exit 1
        fi

  # Step 9: Cleanup old revisions
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'cleanup'
    waitFor: ['verify']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_NAME=$(cat /workspace/service_name.txt)

        echo "Cleaning up old revisions..."

        # Keep last 5 revisions
        gcloud run revisions list \
          --service=$SERVICE_NAME \
          --region=${_REGION} \
          --format='value(name)' \
          --sort-by=~metadata.creationTimestamp \
          | tail -n +6 \
          | xargs -I {} gcloud run revisions delete {} --region=${_REGION} --quiet || true

        echo "Cleanup complete"

  # Step 10: Tag successful build
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'tag-success'
    waitFor: ['verify']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        ENVIRONMENT=$(cat /workspace/environment.txt)
        SERVICE_URL=$(cat /workspace/service_url.txt)

        echo "=========================================="
        echo "Deployment Successful!"
        echo "=========================================="
        echo "Environment: $ENVIRONMENT"
        echo "Service URL: $SERVICE_URL"
        echo "Image: us-docker.pkg.dev/${PROJECT_ID}/convergence/api:${SHORT_SHA}"
        echo "Build ID: ${BUILD_ID}"
        echo "=========================================="

# Timeout for entire build
timeout: 1800s

# Build options
options:
  machineType: 'N1_HIGHCPU_8'
  logging: CLOUD_LOGGING_ONLY
  dynamicSubstitutions: true

# Substitutions (can be overridden)
substitutions:
  _REGION: 'us-central1'
  _ENVIRONMENT: ''  # If not set, determined from branch name

# Images to store in Artifact Registry
images:
  - 'us-docker.pkg.dev/${PROJECT_ID}/convergence/api:${SHORT_SHA}'
  - 'us-docker.pkg.dev/${PROJECT_ID}/convergence/api:${BRANCH_NAME}-latest'
  - 'us-docker.pkg.dev/${PROJECT_ID}/convergence/api:latest'
